// 测试版本 只用于检测程序是否有效
//  | x2 |        | x1 |
//  | y2 |  = A * | y1 | + B
//   
//   A = | 0.75  0.5 |   B = | 20 |
//       | -0.5  0.75|       | -20 |   A与B是系数  是固定的，执行特定的仿射变换
// 

// 指令LOAD测试
00000000000000000 // NOP 清空
10000100000000001 // LOAD %1 %0 0 加载sw到1号寄存器
00000000000000000 // NOP 清空
10001000000000010 // LOAD %2 &0 2 加载sw到2号寄存器
00000000000000000
11100100101100000  //19960//MULI %1, %0, 0.75; // %1 = X1*0.75
11101001001000000  //1A240//MULI %2, %0, 0.5;	// %2 = Y1*0.5	
01001000100000000  //05C00//ADD  %2, %1;       //%2 = %2+%1
11101000111000000  //19AC0//MULI %2, %1, -0.5; //%5 = X1*(-0.5)
11111001001100000  //1B260//MULI %6, %2, 0.75;	//%6 = Y1*0.75	    // 这里出现重大问题 我不能直接赋值，我需要a+b 不能直接付给a 
01010111000000000  //06E00//ADD  %5, %6;       //%5 = %5+%6    目前为止%3 存 0.75 * x1 + 0.5*y1   %5 存 -0.5 * x1 + 0.75 * y1
11001100000010100  //15B14//ADDI %3, %3, 20;   //%3 = %3+20 + 系数 B
11010100011101100  //16DEC//ADDI %5, %5, -20;  //%5 = %5-20 + 系数 B
//显示
01011001100000000  // ADD %6 %3 0  %6 = %6 + %3   x2
01011110100000000  // ADD %7 %5 0  %7 = %7 + %5   y2
00000000000000000


// 测试加法
//01001000100000000 // ADD %2 %1   %2 = %2+%1  加法 将2号和1号加起来给2号
// 测试加立即数
//11001000000000011 //ADDI %2 %0 3  此时%2应该是6
// 测试乘法
//11101000001100000 // MULI %2 %0 0.75 得出的结果应该是 4.5  00000100 只取整数部分
// reg8存数据
//01011101000000000  // ADD %7 %2 0  %7 = %7 + %2 